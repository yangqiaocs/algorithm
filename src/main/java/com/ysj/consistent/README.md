一致性哈希算法
如果我们期望每次过来的请求都打在相同的服务器上，那么我们可以使用哈希算法来每次都将请求中保持不变的信息（如IP地址，请求中携带的相同的token等），这样一来hash之后，便可以得到一个int型的hash值，再使用这个hash值来对服务器的数量取余，就可以得到请求该打到的服务地址，但是这样在每次服务器的数量发生了增加或者减少时，原本的hash值没有变，但是取模的值变了，这样就会导致所有的请求几乎都会丢失原来的服务端信息，因此我们使用一致性哈希算法来解决上述问题

简单点描述，假设我们的hash函数得到的值是0-15，那么可以将hash值在0-3之间的请求发到服务器A, 
hash值在4-7的请求发到服务器B,8-15的请求发送到C 。

但是我们正常的hash值是一个int 
型的数字，因此，我们在使用少量的服务器时，可能会存在服务全部集中在一个区间如4-7上 ，也就是所有的请求都打到同一台服务器上。一个简单的解决办法就是使hash函数之后的hash
值尽可能的分散吗，但是治标不治本，另一种解决方案就是每个服务器增加一些虚拟节点在0-15之间。比如每个服务器增加三个虚拟节点，这样即使所有的服务hash值都在4-7之间，但是我们的4-7之间增加了所有的其他服务器的节点比如4对应的A服务器，5 -> B，6，7 -> C,这样即使服务hash值很集中，也仍然可以打到负载均衡的效果。

还有一个问题是出现的节点下线或者新增节点
如果新增了服务器D，那么就让他接收12-15之间的请求，也就是原本的

| 服务器 | 哈希值  |
|:---:|:----:|
| A   | 0-3  |
| B   | 4-7  |
| C   | 8-15 |

变成了

| 服务器 |  哈希值  |
|:---:|:-----:|
|  A  |  0-3  |
|  B  |  4-7  |
|  C  | 8-11  |
|  D  | 12-15 |
当加入了虚拟节点

| 服务器 |    哈希值    |
|:---:|:---------:|
|  A  | 0,4,8,12  |
|  B  | 1,5,9,13  |
|  C  | 2,6,10,14 |
|  D  | 3,7,11,15 |
当然事实上是一个区间对应一个节点，这里为了方便举例，欢迎留言讨论
